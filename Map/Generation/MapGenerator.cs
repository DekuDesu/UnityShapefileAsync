using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Threading;
using System.Diagnostics;
using System.Collections.Concurrent;
using UnityEngine;
using PSS.MultiThreading;
using PSS.MultiThreading.DataAccess;
namespace PSS.Mapping
{
    /// <summary>
    /// Object that generates a map
    /// </summary>
    public class MapGenerator : BaseMultiThreaded, IMultiThreaded
    {
        /// <summary>
        /// The list of map pieces that this map generator hase generated sofar
        /// </summary>
        public List<MapPiece> MapPieces { get; private set; } = new List<MapPiece>();

        /// <summary>
        /// The number of map pieces that this generator has completed so far
        /// </summary>
        public int PiecesGenerated => Consumer != null ? Consumer.ItemsConsumed : 0;

        /// <summary>
        /// Whether or not this generator is currently generating objects
        /// </summary>
        public bool GeneratingPieces { get; private set; }

        /// <summary>
        /// The list of IDs of the objects generated by this map generator
        /// </summary>
        public ConcurrentBag<int> GeneratedIDs { get; private set; } = new ConcurrentBag<int>();

        /// <summary>
        /// The <see cref="LineUtility.Simplify"/> tolerance that should be used when simplifying the points, this is used specifically with <see cref="GenerateLinePieces"/>
        /// </summary>
        public float SimplifyTolerace { get; set; } = 0.05f;

        /// <summary>
        /// The tolerance that should be used to create the polygon, this is used with <see cref="GeneratePolyPieces"/>
        /// </summary>
        public double MeshGenerationTolerace { get; set; } = 1e-10;

        /// <summary>
        /// The default material used to apply to new poly pieces
        /// </summary>
        public Material Material { get; set; }

        private IMapReader Reader;

        private bool UsePolygons { get; set; } = false;

        private Consumer<int, IMapRecord, ConcurrentBag<int>, ConcurrentBag<IMapRecord>> Consumer { get; set; } = new Consumer<int, IMapRecord, ConcurrentBag<int>, ConcurrentBag<IMapRecord>>();

        /// <summary>
        /// Generates a map using the given readers processed records. If no Material is given as a param then it generates lines instead of polygon planes
        /// </summary>
        /// <param name="MapRecords"></param>
        /// <param name="reader"></param>
        /// <param name="mat"></param>
        /// <returns></returns>
        public void GenerateMap(IMapReader reader, bool usePolygons, Material mat = null)
        {
            //Stopwatch watch = Stopwatch.StartNew();

            this.Material = mat;

            this.Reader = reader ?? throw new ArgumentNullException();

            this.UsePolygons = usePolygons;

            // the workers wait for the reader to start running before they begin work.
            UpdateStatus(TaskStatus.WaitingToRun);

            CreateWorkers(GetReasonableMaxThreads());

            WaitTasks();

            GeneratingPieces = false;
        }

        private void CreateWorkers(int numberOfWorkers)
        {
            Consumer = new Consumer<int, IMapRecord, ConcurrentBag<int>, ConcurrentBag<IMapRecord>>();

            Consumer.Input = Reader.MapRecords;

            if (UsePolygons)
            {
                Consumer.Operation = GeneratePolyOperation;
            }
            else
            {
                Consumer.Operation = GenerateLineOperation;
            }

            Consumer.KeepAlive = true;

            UpdateStatus(TaskStatus.Running);

            GeneratingPieces = true;

            Consumer.SetKeepAliveEvent((IMultiThreaded)Reader, TaskStatus.RanToCompletion, false);

            Run(() => Consumer.BeginConsuming(numberOfWorkers));
        }

        private int GetReasonableMaxThreads()
        {
            bool weak = Environment.ProcessorCount < 4;
            if (weak)
            {
                return 1;
            }
            return Environment.ProcessorCount - 3;
        }

        private int GeneratePolyOperation(IMapRecord record)
        {
            if (record == null || record.points == null)
            {
                return 0;
            }
            int id = record.Name.GetHashCode();
            GeneratedIDs.Add(id); // keep track of the generated ids so we can locate them later
            IMesh mesh = Helpers.MapGenerationHelpers.CreateMesh(record.points);
            if (mesh == null)
            {
                return 0;
            }
            Color c = Helpers.MapGenerationHelpers.GetRandomColor();
            Helpers.MapGenerationHelpers.CreateGameObjectWithMesh(record.Name, mesh, this.Material, c);
            return 0;
        }

        private int GenerateLineOperation(IMapRecord record)
        {
            if (record == null || record.points == null)
            {
                return 0;
            }
            int id = record.Name.GetHashCode();
            GeneratedIDs.Add(id); // keep track of the generated ids so we can locate them later
            Color c = Helpers.MapGenerationHelpers.GetRandomColor();
            Helpers.MapGenerationHelpers.CreateGameObjectWithLine(id, record, 0.05f, c, 0.01f);
            return 0;
        }

        public override void Cancel()
        {
            Consumer?.Cancel();
            Reader?.Cancel();
            base.Cancel();
        }
    }
}
